#include <string>
#include <queue>
#include <iostream>

using std::string;
using std::queue;
using std::to_string;

struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
    public :
        Solution() {}

	string serialize(TreeNode* root) {
		if (!root) return "";
		string result;
		queue<TreeNode*> que;
		queue<TreeNode*> nextRound;

		result = result + to_string(root->val);
		que.emplace(root->left);
		que.emplace(root->right);

		while (!que.empty()) {
			TreeNode* node = que.front();
			que.pop();

			if (!node) result += ",null";
			else {
				result += "," + to_string(node->val);
				nextRound.emplace(node->left);
				nextRound.emplace(node->right);
			}
			if (que.empty()) que = move(nextRound);
		}

		return result;
	}

	// Decodes your encoded data to tree.
	TreeNode* deserialize(string data) {
		if (data.empty()) return nullptr;
		int left = 0, right = left;
		queue<TreeNode*> nodeQue;
		while (right < data.size()) {
			while (data[right] != ',' && right < data.size()) {
				++right;
			}
			string numStr = data.substr(left, right - left);
			if (numStr == "null") nodeQue.emplace(nullptr);
			else {
				int num = stoi(numStr);
				TreeNode* node = new TreeNode(num);
				nodeQue.emplace(node);
			}
			left = right + 1;
			right = left;
		}

		TreeNode* head = nodeQue.front();
		nodeQue.pop();
		queue<TreeNode*> cur;
		queue<TreeNode*> next;
		cur.emplace(head);
		while (!cur.empty() && !nodeQue.empty()) {
			TreeNode* node = cur.front();
			cur.pop();
			if (node) {
				node->left = nodeQue.front();
				if (node->left) next.emplace(node->left);
				nodeQue.pop();
				node->right = nodeQue.front();
				if (node->right) next.emplace(node->right);
				nodeQue.pop();
			}

			if (cur.empty()) cur = move(next);
		}
		return head;
	}
    private :
        virtual ~Solution() {}
        Solution& operator=(const Solution& source);
        Solution(const Solution&);
};

